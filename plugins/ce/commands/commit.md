---
description: Create a well-formatted git commit for current changes
argument-hint: "[context]"
allowed-tools: Bash, Task
---

Create a git commit using the appropriate path based on your current knowledge.

## Decision: Direct vs Delegate

**Commit directly** if you have clear context about the changes:
- You just implemented, fixed, or modified something in this conversation
- You know exactly what files changed and why
- The intent of the change is unambiguous

**Delegate to haiku agent** if ambiguous:
- User invoked `/ce:commit` without prior context in this conversation
- You're unsure what changes exist or their purpose
- The user is asking about changes you didn't make

## Path A: Direct Commit (You Have Context)

1. **Quick verification:**
   ```bash
   git diff --cached --name-only  # or git diff --name-only for unstaged
   ```
   Confirm the files match what you expect from your work.

2. **Draft the message** following Conventional Commits (schema below).

3. **Execute:**
   ```bash
   git commit -m "your_header" -m "your_body"
   ```

4. **Handle failure:** If pre-commit hooks fail, report the error and stop. Don't auto-fix.

## Path B: Delegate to Haiku Agent (Ambiguous)

Invoke `ce:haiku` agent via Task tool with this prompt:

```
Create a git commit.

User arguments: $ARGUMENTS
Default context: staged (use "unstaged" only if user specifies)

**Step 1: Context Gathering**
- Execute `git log -n 10 --oneline` to learn the project's existing casing and scoping conventions
- Execute `git diff --cached --name-only` (for staged) or `git diff --name-only` (for unstaged) to see the file list
- Execute `git diff --cached` (for staged) or `git diff` (for unstaged) to read the code changes

**Step 2: Analysis & Drafting**
- Analyze the *intent* of the change (Why was this done?), not just the syntax (What changed?)
- Infer the **scope** from the directory name or module (e.g., `src/auth/login.ts` -> `auth`). Avoid file extensions in scopes
- Draft the message following **Conventional Commits** (rules below)

**Step 3: Execution**
- Print the drafted message clearly so the user sees what is being committed
- Execute: `git commit -m "your_header" -m "your_body"`
- Pass the header and body as separate `-m` flags for proper newline formatting

**Failure Handling (Pre-commit Hooks)**

If `git commit` fails (exit code != 0):
1. STOP. Do not attempt to fix linting or test errors
2. REPORT with:
   - Status: FAILED
   - Error Output: The stderr from the git command
   - Drafted Message: The message you tried to use
   - Recommendation: "Please fix the errors listed above"
```

## Conventional Commits Schema

Format:
`<type>(<scope>): <subject>`
`<BLANK LINE>`
`<body>`

Allowed Types:
- `feat`: New feature for the user
- `fix`: Bug fix for the user
- `docs`: Documentation only
- `style`: Formatting, missing semi-colons, etc.
- `refactor`: Code change that neither fixes a bug nor adds a feature
- `perf`: Performance improvements
- `test`: Adding or correcting tests
- `build`: Build system/dependencies
- `ci`: CI configuration
- `chore`: Maintenance (no src/test changes)

Style Rules:
- Imperative Mood: "Add" not "Added", "Fix" not "Fixed"
- Header: Max 50 chars, lowercase, no ending period
- Body: Wrap at 72 chars. Focus on **WHY** the change is necessary
- Breaking Changes: Use `feat!:` or `fix!:` syntax and start body with `BREAKING CHANGE:`

**Important:**
- Do not add attribution footers (no "Generated by...")
- If the diff is massive, focus on the *primary* architectural change rather than listing every file
